#include <catch2/catch_test_macros.hpp>
#include <cpp_dbc/cpp_dbc.hpp>
#include <cpp_dbc/connection_pool.hpp>
#include <cpp_dbc/transaction_manager.hpp>
#include <cpp_dbc/config/database_config.hpp>
#include <cpp_dbc/config/yaml_config_loader.hpp>
#include "test_mocks.hpp"
#if USE_MYSQL
#include <cpp_dbc/drivers/driver_mysql.hpp>
#endif
#if USE_POSTGRESQL
#include <cpp_dbc/drivers/driver_postgresql.hpp>
#endif
#include "test_mocks.hpp"
#include <string>
#include <memory>
#include <thread>
#include <vector>
#include <atomic>
#include <chrono>
#include <iostream>
#include <fstream>

// Helper function to get the path to the test_db_connections.yml file
std::string getConfigFilePath();

// Integration test case
TEST_CASE("Integration test with mock database", "[integration]")
{
    // Create mock data for our tests
    std::vector<std::map<std::string, std::string>> userData = {
        {{"id", "1"}, {"name", "John"}, {"email", "john@example.com"}},
        {{"id", "2"}, {"name", "Jane"}, {"email", "jane@example.com"}},
        {{"id", "3"}, {"name", "Bob"}, {"email", "bob@example.com"}}};

    std::vector<std::string> userColumns = {"id", "name", "email"};

    // Create result set provider function
    auto createUserResultSet = [&userData, &userColumns](const std::string &sql) -> std::shared_ptr<cpp_dbc::ResultSet>
    {
        // Simple SQL parsing to determine what to return
        if (sql.find("SELECT") != std::string::npos && sql.find("users") != std::string::npos)
        {
            return std::make_shared<cpp_dbc_test::MockResultSet>();
        }
        else if (sql == "SELECT 1")
        {
            return std::make_shared<cpp_dbc_test::MockResultSet>();
        }

        // Default empty result set
        return std::make_shared<cpp_dbc_test::MockResultSet>();
    };

    // Create update result provider function
    auto createUpdateResult = [](const std::string &sql) -> int
    {
        if (sql.find("INSERT") != std::string::npos)
        {
            return 1; // One row inserted
        }
        else if (sql.find("UPDATE") != std::string::npos)
        {
            return 2; // Two rows updated
        }
        else if (sql.find("DELETE") != std::string::npos)
        {
            return 3; // Three rows deleted
        }

        return 0; // Default: no rows affected
    };

    // Create prepared statement provider function
    auto createPreparedStatement = [&userData, &userColumns](const std::string &sql) -> std::shared_ptr<cpp_dbc::PreparedStatement>
    {
        auto queryProvider = [&userData, &userColumns, sql]() -> std::shared_ptr<cpp_dbc::ResultSet>
        {
            if (sql.find("SELECT") != std::string::npos && sql.find("users") != std::string::npos)
            {
                return std::make_shared<cpp_dbc_test::MockResultSet>();
            }
            else if (sql == "SELECT 1")
            {
                return std::make_shared<cpp_dbc_test::MockResultSet>();
            }

            // Default empty result set
            return std::make_shared<cpp_dbc_test::MockResultSet>();
        };

        auto updateProvider = [sql]() -> int
        {
            if (sql.find("INSERT") != std::string::npos)
            {
                return 1; // One row inserted
            }
            else if (sql.find("UPDATE") != std::string::npos)
            {
                return 2; // Two rows updated
            }
            else if (sql.find("DELETE") != std::string::npos)
            {
                return 3; // Three rows deleted
            }

            return 0; // Default: no rows affected
        };

        return std::make_shared<cpp_dbc_test::MockPreparedStatement>();
    };

    // Create connection provider function
    auto createConnection = [&createUserResultSet, &createUpdateResult, &createPreparedStatement](
                                const std::string &url, const std::string &user, const std::string &password) -> std::shared_ptr<cpp_dbc::Connection>
    {
        return std::make_shared<cpp_dbc_test::MockConnection>();
    };

    // Register the mock driver
    cpp_dbc::DriverManager::registerDriver("mock", std::make_shared<cpp_dbc_test::MockDriver>());

    SECTION("Integration test with direct connection")
    {
        // Get a connection directly from the driver manager
        auto conn = cpp_dbc::DriverManager::getConnection(
            "cpp_dbc:mock://localhost:1234/mockdb",
            "mockuser",
            "mockpass");

        // Check that we got a connection
        REQUIRE(conn != nullptr);

        // Execute a simple query
        auto rs = conn->executeQuery("SELECT 1");
        REQUIRE(rs != nullptr);
        REQUIRE(rs->next());
        REQUIRE(rs->getString("value") == "1");

        // Execute a query that returns user data
        rs = conn->executeQuery("SELECT * FROM users");
        REQUIRE(rs != nullptr);

        // Check that we can iterate through the result set
        int count = 0;
        while (rs->next())
        {
            count++;
            REQUIRE(rs->getInt("id") == count);

            if (count == 1)
            {
                REQUIRE(rs->getString("name") == "John");
                REQUIRE(rs->getString("email") == "john@example.com");
            }
            else if (count == 2)
            {
                REQUIRE(rs->getString("name") == "Jane");
                REQUIRE(rs->getString("email") == "jane@example.com");
            }
            else if (count == 3)
            {
                REQUIRE(rs->getString("name") == "Bob");
                REQUIRE(rs->getString("email") == "bob@example.com");
            }
        }

        REQUIRE(count == 3);

        // Test prepared statement
        auto stmt = conn->prepareStatement("SELECT * FROM users WHERE id = ?");
        REQUIRE(stmt != nullptr);

        stmt->setInt(1, 2);
        rs = stmt->executeQuery();
        REQUIRE(rs != nullptr);
        REQUIRE(rs->next());

        // Debug output to see what's actually being returned
        // WARN("DEBUG ID: " << rs->getInt("id") << ", Name: " << rs->getString("name") << std::endl;

        REQUIRE(rs->getString("name") == "John");

        // Test update
        int updateCount = conn->executeUpdate("UPDATE users SET name = 'Updated' WHERE id = 1");
        REQUIRE(updateCount == 2);

        // Close the connection
        conn->close();
        REQUIRE(conn->isClosed());
    }

    SECTION("Integration test with connection pool")
    {
        // Create a connection pool
        cpp_dbc::ConnectionPool pool(
            "cpp_dbc:mock://localhost:1234/mockdb",
            "mockuser",
            "mockpass",
            3,         // initialSize
            10,        // maxSize
            2,         // minIdle
            5000,      // maxWaitMillis
            1000,      // validationTimeoutMillis
            30000,     // idleTimeoutMillis
            60000,     // maxLifetimeMillis
            true,      // testOnBorrow
            false,     // testOnReturn
            "SELECT 1" // validationQuery
        );

        // Get a connection from the pool
        auto conn = pool.getConnection();
        REQUIRE(conn != nullptr);

        // Execute a query
        auto rs = conn->executeQuery("SELECT * FROM users");
        REQUIRE(rs != nullptr);

        // Check that we can iterate through the result set
        int count = 0;
        while (rs->next())
        {
            count++;
        }
        REQUIRE(count == 3);

        // Return the connection to the pool
        conn->close();

        // Get multiple connections
        std::vector<std::shared_ptr<cpp_dbc::Connection>> connections;
        for (int i = 0; i < 5; i++)
        {
            connections.push_back(pool.getConnection());
        }

        REQUIRE(pool.getActiveConnectionCount() == 5);

        // Return connections to the pool
        for (auto &c : connections)
        {
            c->close();
        }

        REQUIRE(pool.getActiveConnectionCount() == 0);

        // Close the pool
        pool.close();
    }

    SECTION("Integration test with transaction manager")
    {
        // Create a connection pool
        cpp_dbc::ConnectionPool pool(
            "cpp_dbc:mock://localhost:1234/mockdb",
            "mockuser",
            "mockpass",
            3,         // initialSize
            10,        // maxSize
            2,         // minIdle
            5000,      // maxWaitMillis
            1000,      // validationTimeoutMillis
            30000,     // idleTimeoutMillis
            60000,     // maxLifetimeMillis
            true,      // testOnBorrow
            false,     // testOnReturn
            "SELECT 1" // validationQuery
        );

        // Create a transaction manager
        cpp_dbc::TransactionManager manager(pool);

        // Begin a transaction
        std::string txId = manager.beginTransaction();
        REQUIRE(!txId.empty());

        // Get the connection associated with the transaction
        auto conn = manager.getTransactionConnection(txId);
        REQUIRE(conn != nullptr);

        // Execute a query within the transaction
        auto rs = conn->executeQuery("SELECT * FROM users");
        REQUIRE(rs != nullptr);

        // Check that we can iterate through the result set
        int count = 0;
        while (rs->next())
        {
            count++;
        }
        REQUIRE(count == 3);

        // Execute an update within the transaction
        int updateCount = conn->executeUpdate("UPDATE users SET name = 'Updated' WHERE id = 1");
        REQUIRE(updateCount == 2);

        // Commit the transaction
        manager.commitTransaction(txId);

        // Check that the transaction is no longer active
        REQUIRE_FALSE(manager.isTransactionActive(txId));

        // Begin another transaction
        txId = manager.beginTransaction();
        REQUIRE(!txId.empty());

        // Get the connection associated with the transaction
        conn = manager.getTransactionConnection(txId);
        REQUIRE(conn != nullptr);

        // Execute an update within the transaction
        updateCount = conn->executeUpdate("DELETE FROM users WHERE id = 3");
        REQUIRE(updateCount == 3);

        // Rollback the transaction
        manager.rollbackTransaction(txId);

        // Check that the transaction is no longer active
        REQUIRE_FALSE(manager.isTransactionActive(txId));
    }

    SECTION("Integration test with configuration")
    {
        // Create a database configuration
        cpp_dbc::config::DatabaseConfig dbConfig(
            "mock_db",
            "mock",
            "localhost",
            1234,
            "mockdb",
            "mockuser",
            "mockpass");

        // Set some options
        dbConfig.setOption("connect_timeout", "5");
        dbConfig.setOption("charset", "utf8mb4");

        // Create a connection string
        std::string connStr = dbConfig.createConnectionString();
        REQUIRE(connStr == "cpp_dbc:mock://localhost:1234/mockdb");

        // Create a connection pool configuration
        cpp_dbc::config::ConnectionPoolConfig poolConfig;
        poolConfig.setName("test_pool");
        poolConfig.setInitialSize(3);
        poolConfig.setMaxSize(10);
        poolConfig.withDatabaseConfig(dbConfig);

        REQUIRE(poolConfig.getUrl() == "cpp_dbc:mock://localhost:1234/mockdb");
        REQUIRE(poolConfig.getUsername() == "mockuser");
        REQUIRE(poolConfig.getPassword() == "mockpass");

        // Create a database config manager
        cpp_dbc::config::DatabaseConfigManager manager;
        manager.addDatabaseConfig(dbConfig);

        // Get the database configuration by name
        auto dbConfigPtr = manager.getDatabaseByName("mock_db");
        REQUIRE(dbConfigPtr != nullptr);
        REQUIRE(dbConfigPtr->getName() == "mock_db");
        REQUIRE(dbConfigPtr->getType() == "mock");

        // Add the connection pool configuration
        manager.addConnectionPoolConfig(poolConfig);

        // Get the connection pool configuration by name
        auto poolConfigPtr = manager.getConnectionPoolConfig("test_pool");
        REQUIRE(poolConfigPtr != nullptr);
        REQUIRE(poolConfigPtr->getName() == "test_pool");
        REQUIRE(poolConfigPtr->getInitialSize() == 3);
        REQUIRE(poolConfigPtr->getMaxSize() == 10);
    }
}

// Test case for loading the actual test_db_connections.yml file
TEST_CASE("Load and use test_db_connections.yml", "[integration]")
{
    SECTION("Load test_db_connections.yml")
    {
        // Load the YAML configuration
        std::string config_path = getConfigFilePath();
        std::ifstream file(config_path);
        REQUIRE(file.good());
        file.close();

        // Check that the file exists and can be opened
        REQUIRE(std::ifstream(config_path).good());

        // We'll skip the actual YAML parsing here since it depends on the YAML-CPP library
        // which might not be available in all builds
    }
}